import { GeneratedFile, FileTree, Change } from './types'

export class FileManager {
  /**
   * Save a single file to the database
   */
  async saveFile(projectId: string, file: GeneratedFile): Promise<any> {
    // Check for conflicts
    const existingFile = await this.getFile(projectId, file.path)

    if (existingFile) {
      console.warn(`File ${file.path} already exists. Consider using updateFile() instead.`)
      // Create backup
      await this.createBackup(projectId, file.path)
    }

    // In a real implementation, this would save to the database
    // For now, we'll return a mock File object
    const savedFile = {
      id: Math.random().toString(36).substring(7),
      projectId,
      path: file.path,
      content: file.content,
      language: file.language,
      type: file.type,
      explanation: file.explanation,
      createdAt: new Date(),
      updatedAt: new Date(),
    }

    // Create Change record
    await this.createChange({
      id: Math.random().toString(36).substring(7),
      projectId,
      description: `Created file: ${file.path}`,
      reasoning: file.explanation || 'File generated by AI',
      filesAffected: [file.path],
      createdAt: new Date(),
      createdBy: 'ai',
    })

    return savedFile
  }

  /**
   * Update an existing file
   */
  async updateFile(
    projectId: string,
    path: string,
    content: string,
    reason: string
  ): Promise<any> {
    const existingFile = await this.getFile(projectId, path)

    if (!existingFile) {
      throw new Error(`File ${path} not found`)
    }

    // Calculate diff
    const diff = this.calculateDiff(existingFile.content, content)

    // Update file
    const updatedFile = {
      ...existingFile,
      content,
      updatedAt: new Date(),
    }

    // Create Change record with diff
    await this.createChange({
      id: Math.random().toString(36).substring(7),
      projectId,
      description: `Updated file: ${path}`,
      reasoning: reason,
      filesAffected: [path],
      createdAt: new Date(),
      createdBy: 'ai',
    })

    return updatedFile
  }

  /**
   * Delete a file (soft delete)
   */
  async deleteFile(projectId: string, path: string, reason: string): Promise<void> {
    const existingFile = await this.getFile(projectId, path)

    if (!existingFile) {
      throw new Error(`File ${path} not found`)
    }

    // Soft delete - mark as deleted but keep in history
    // In real implementation, would update database record

    // Create Change record
    await this.createChange({
      id: Math.random().toString(36).substring(7),
      projectId,
      description: `Deleted file: ${path}`,
      reasoning: reason,
      filesAffected: [path],
      createdAt: new Date(),
      createdBy: 'ai',
    })
  }

  /**
   * Get a file by path
   */
  async getFile(projectId: string, path: string): Promise<any | null> {
    // In real implementation, would query database
    // For now, return null
    return null
  }

  /**
   * Get all files for a project
   */
  async getFiles(projectId: string): Promise<any[]> {
    // In real implementation, would query database
    // For now, return empty array
    return []
  }

  /**
   * Get file tree structure
   */
  async getFileTree(projectId: string): Promise<FileTree> {
    const files = await this.getFiles(projectId)
    return this.buildFileTree(files)
  }

  /**
   * Bulk save multiple files atomically
   */
  async bulkSave(
    projectId: string,
    files: GeneratedFile[],
    changeDescription: string
  ): Promise<any[]> {
    try {
      // Save all files
      const savedFiles = await Promise.all(
        files.map((file) => this.saveFile(projectId, file))
      )

      // Create single Change record for all files
      await this.createChange({
        id: Math.random().toString(36).substring(7),
        projectId,
        description: changeDescription,
        reasoning: `Bulk file creation: ${files.length} files`,
        filesAffected: files.map((f) => f.path),
        createdAt: new Date(),
        createdBy: 'ai',
      })

      return savedFiles
    } catch (error) {
      // Rollback on failure
      console.error('Bulk save failed, rolling back:', error)
      throw error
    }
  }

  /**
   * Create a backup of an existing file
   */
  private async createBackup(projectId: string, path: string): Promise<void> {
    const file = await this.getFile(projectId, path)
    if (!file) return

    const backupPath = `${path}.backup`
    // In real implementation, would save backup to database
    console.log(`Created backup: ${backupPath}`)
  }

  /**
   * Calculate diff between two file contents
   */
  private calculateDiff(oldContent: string, newContent: string): string {
    // Simple line-based diff
    const oldLines = oldContent.split('\n')
    const newLines = newContent.split('\n')

    const diff: string[] = []
    const maxLines = Math.max(oldLines.length, newLines.length)

    for (let i = 0; i < maxLines; i++) {
      if (oldLines[i] !== newLines[i]) {
        if (oldLines[i]) diff.push(`- ${oldLines[i]}`)
        if (newLines[i]) diff.push(`+ ${newLines[i]}`)
      }
    }

    return diff.join('\n')
  }

  /**
   * Build file tree from flat file list
   */
  private buildFileTree(files: any[]): FileTree {
    const root: FileTree = {
      name: 'root',
      type: 'directory',
      path: '',
      children: [],
    }

    files.forEach((file) => {
      const parts = file.path.split('/')
      let current = root

      parts.forEach((part, index) => {
        if (!current.children) current.children = []

        let child = current.children.find((c) => c.name === part)

        if (!child) {
          child = {
            name: part,
            type: index === parts.length - 1 ? 'file' : 'directory',
            path: parts.slice(0, index + 1).join('/'),
            children: index === parts.length - 1 ? undefined : [],
          }

          if (index === parts.length - 1) {
            child.size = file.content?.length || 0
            child.language = file.language
          }

          current.children.push(child)
        }

        if (child.type === 'directory') {
          current = child
        }
      })
    })

    return root
  }

  /**
   * Create a Change record
   */
  private async createChange(change: Change): Promise<void> {
    // In real implementation, would save to database
    console.log('Change created:', change.description)
  }
}
